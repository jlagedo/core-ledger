# Angular API Client Usage Guide

This guide explains how to use the Kiota-generated API client in Angular components and services.

## Overview

The Core Ledger Angular frontend now uses the type-safe API client generated by Microsoft Kiota. This integration:

- ‚úÖ Provides full TypeScript type safety for all API calls
- ‚úÖ Works with Angular's HttpClient and HTTP interceptors
- ‚úÖ Supports mock API for offline development
- ‚úÖ Maintains authentication through Angular HTTP interceptors
- ‚úÖ Auto-generated from the .NET API OpenAPI specification

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Angular Component/Service      ‚îÇ
‚îÇ  - Injects ApiClientService     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ApiClientService                ‚îÇ
‚îÇ  - Wraps Kiota client            ‚îÇ
‚îÇ  - Provides convenience methods  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AngularRequestAdapter           ‚îÇ
‚îÇ  - Bridges Kiota ‚Üí HttpClient    ‚îÇ
‚îÇ  - Integrates with interceptors  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Angular HttpClient              ‚îÇ
‚îÇ  - Authentication interceptor    ‚îÇ
‚îÇ  - Mock API interceptor          ‚îÇ
‚îÇ  - Error handling                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  .NET API / Mock API             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Basic Usage

### 1. Import the Service

```typescript
import { inject, Injectable } from '@angular/core';
import { ApiClientService } from '../api/api-client.service';

@Injectable({ providedIn: 'root' })
export class MyService {
  private readonly apiClient = inject(ApiClientService);
}
```

### 2. Make API Calls

The Kiota client uses Promises (not Observables). Wrap calls with `from()` to convert to Observables if needed.

#### Using Promises (Recommended for Simple Calls)

```typescript
async loadFunds() {
  try {
    const funds = await this.apiClient.fundos.get();
    console.log(funds);
  } catch (error) {
    console.error('Failed to load funds:', error);
  }
}
```

#### Using Observables (for RxJS Pipelines)

```typescript
import { from } from 'rxjs';
import { map, catchError } from 'rxjs/operators';

loadFunds() {
  return from(this.apiClient.fundos.get()).pipe(
    map(response => response?.items ?? []),
    catchError(error => {
      console.error('Failed to load funds:', error);
      return of([]);
    })
  );
}
```

## Common Patterns

### GET - List Entities

```typescript
import { inject } from '@angular/core';
import { ApiClientService } from '../api/api-client.service';
import { signal } from '@angular/core';

export class FundsListComponent {
  private readonly apiClient = inject(ApiClientService);

  readonly funds = signal<any[]>([]);
  readonly loading = signal(true);
  readonly error = signal<string | null>(null);

  async ngOnInit() {
    try {
      this.loading.set(true);
      const response = await this.apiClient.fundos.get();
      this.funds.set(response?.items ?? []);
    } catch (err: any) {
      this.error.set(err.message);
    } finally {
      this.loading.set(false);
    }
  }
}
```

### GET - Single Entity by ID

```typescript
async loadFund(fundoId: string) {
  try {
    const fund = await this.apiClient.fundos.item(fundoId).get();
    return fund;
  } catch (error) {
    console.error('Failed to load fund:', error);
    throw error;
  }
}
```

### POST - Create Entity

```typescript
import { type FundoCreateDto } from '@core-ledger/api-client';

async createFund(data: FundoCreateDto) {
  try {
    const created = await this.apiClient.fundos.post(data);
    console.log('Fund created:', created);
    return created;
  } catch (error) {
    console.error('Failed to create fund:', error);
    throw error;
  }
}
```

### PUT - Update Entity

```typescript
import { type FundoUpdateDto } from '@core-ledger/api-client';

async updateFund(fundoId: string, data: FundoUpdateDto) {
  try {
    await this.apiClient.fundos.item(fundoId).put(data);
    console.log('Fund updated');
  } catch (error) {
    console.error('Failed to update fund:', error);
    throw error;
  }
}
```

### DELETE - Delete Entity

```typescript
async deleteFund(fundoId: string) {
  try {
    await this.apiClient.fundos.item(fundoId).delete();
    console.log('Fund deleted');
  } catch (error) {
    console.error('Failed to delete fund:', error);
    throw error;
  }
}
```

### Custom Endpoints (e.g., CNPJ Verification)

```typescript
import { type CnpjDisponibilidadeResponseDto } from '@core-ledger/api-client';

async verificarCnpj(cnpj: string): Promise<CnpjDisponibilidadeResponseDto | undefined> {
  try {
    return await this.apiClient.fundos.verificarCnpj.byCnpj(cnpj).get();
  } catch (error) {
    console.error('CNPJ verification failed:', error);
    throw error;
  }
}
```

## Using with Angular Signals

Angular 21 uses signals for reactive state. Here's a complete example:

```typescript
import { Component, inject, signal, computed } from '@angular/core';
import { ApiClientService } from '../../api/api-client.service';
import { ToastService } from '../../services/toast-service';

@Component({
  selector: 'app-funds',
  standalone: true,
  template: `
    <div>
      <h1>Funds</h1>

      @if (loading()) {
        <p>Loading...</p>
      } @else if (error()) {
        <div class="alert alert-danger">{{ error() }}</div>
      } @else {
        <ul>
          @for (fund of funds(); track fund.id) {
            <li>{{ fund.nomeFantasia }}</li>
          }
        </ul>
      }

      <p>Total: {{ totalFunds() }}</p>
    </div>
  `,
})
export class FundsComponent {
  private readonly apiClient = inject(ApiClientService);
  private readonly toastService = inject(ToastService);

  readonly funds = signal<any[]>([]);
  readonly loading = signal(true);
  readonly error = signal<string | null>(null);

  // Computed signal
  readonly totalFunds = computed(() => this.funds().length);

  async ngOnInit() {
    await this.loadFunds();
  }

  async loadFunds() {
    try {
      this.loading.set(true);
      this.error.set(null);

      const response = await this.apiClient.fundos.get();
      this.funds.set(response?.items ?? []);

      this.toastService.success('Funds loaded successfully');
    } catch (err: any) {
      this.error.set(err.message || 'Failed to load funds');
      this.toastService.error('Failed to load funds');
    } finally {
      this.loading.set(false);
    }
  }
}
```

## Migrating Existing Services

### Before (HttpClient)

```typescript
@Injectable({ providedIn: 'root' })
export class FundService {
  private readonly http = inject(HttpClient);
  private readonly apiUrl = inject(API_URL);

  getFunds(): Observable<Fund[]> {
    return this.http.get<Fund[]>(`${this.apiUrl}/fundos`);
  }

  getFund(id: string): Observable<Fund> {
    return this.http.get<Fund>(`${this.apiUrl}/fundos/${id}`);
  }

  createFund(data: CreateFundDto): Observable<Fund> {
    return this.http.post<Fund>(`${this.apiUrl}/fundos`, data);
  }
}
```

### After (API Client)

```typescript
@Injectable({ providedIn: 'root' })
export class FundService {
  private readonly apiClient = inject(ApiClientService);

  getFunds(): Observable<Fund[]> {
    return from(this.apiClient.fundos.get()).pipe(
      map(response => response?.items ?? [])
    );
  }

  getFund(id: string): Observable<Fund | undefined> {
    return from(this.apiClient.fundos.item(id).get());
  }

  createFund(data: CreateFundDto): Observable<Fund | undefined> {
    return from(this.apiClient.fundos.post(data));
  }
}
```

## Accessing Different API Endpoints

The `ApiClientService` provides convenience accessors for common endpoints:

```typescript
// Funds
await this.apiClient.fundos.get();
await this.apiClient.fundos.item('123').get();

// Accounts
await this.apiClient.accounts.get();
await this.apiClient.accounts.item('123').get();

// Securities
await this.apiClient.securities.get();
await this.apiClient.securities.autocomplete.get();

// Transactions
await this.apiClient.transactions.get();

// Indexadores (Indices)
await this.apiClient.indexadores.get();
await this.apiClient.indexadores.item(1).get();

// Users
await this.apiClient.users.me.get();

// Parametros (Parameters)
await this.apiClient.parametros.classificacoesAnbima.get();

// Calendario (Calendar)
await this.apiClient.calendario.get();
await this.apiClient.calendario.item('2024-01-01').get();
```

## Using the Raw Client

For advanced usage or endpoints not exposed through convenience methods:

```typescript
private readonly apiClient = inject(ApiClientService);

async advancedCall() {
  // Access the raw Kiota client
  const client = this.apiClient.client;

  // Use fluent API for any endpoint
  const result = await client.api.v1.fundos.busca.get();
}
```

## Error Handling

The Angular request adapter properly propagates errors through Angular's error handling pipeline:

```typescript
async loadData() {
  try {
    const data = await this.apiClient.fundos.get();
    return data;
  } catch (error: any) {
    // Error is an Angular HttpErrorResponse
    if (error.status === 404) {
      console.log('Not found');
    } else if (error.status === 401) {
      console.log('Unauthorized');
    } else {
      console.error('API error:', error);
    }
    throw error;
  }
}
```

## Type Safety

Import generated DTOs for full type safety:

```typescript
import {
  type FundoCreateDto,
  type FundoUpdateDto,
  type CnpjDisponibilidadeResponseDto
} from '@core-ledger/api-client';

@Injectable({ providedIn: 'root' })
export class MyService {
  private readonly apiClient = inject(ApiClientService);

  async createFund(data: FundoCreateDto) {
    // TypeScript ensures 'data' has correct shape
    return await this.apiClient.fundos.post(data);
  }

  async checkCnpj(cnpj: string): Promise<CnpjDisponibilidadeResponseDto | undefined> {
    // Return type is type-safe
    return await this.apiClient.fundos.verificarCnpj.byCnpj(cnpj).get();
  }
}
```

## Testing

The API client works seamlessly with Angular's mock API system:

```typescript
// In tests, the mock API interceptor will automatically handle requests
describe('FundService', () => {
  let service: FundService;
  let apiClient: ApiClientService;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        FundService,
        ApiClientService,
        // Mock API interceptor is automatically provided
      ],
    });

    service = TestBed.inject(FundService);
    apiClient = TestBed.inject(ApiClientService);
  });

  it('should load funds', async () => {
    const funds = await service.getFunds();
    expect(funds).toBeDefined();
  });
});
```

## Best Practices

### 1. Prefer Async/Await for Simplicity

```typescript
// ‚úÖ Good - Clean and readable
async loadFund(id: string) {
  const fund = await this.apiClient.fundos.item(id).get();
  return fund;
}

// ‚ùå Less ideal - More verbose
loadFund(id: string) {
  return from(this.apiClient.fundos.item(id).get()).pipe(
    map(fund => fund)
  );
}
```

### 2. Use Observables for Reactive Pipelines

```typescript
// ‚úÖ Good - When you need RxJS operators
loadAndFilterFunds() {
  return from(this.apiClient.fundos.get()).pipe(
    map(response => response?.items ?? []),
    map(funds => funds.filter(f => f.status === 'Active')),
    catchError(() => of([]))
  );
}
```

### 3. Centralize API Logic in Services

```typescript
// ‚úÖ Good - Service encapsulates API logic
@Injectable({ providedIn: 'root' })
export class FundService {
  private readonly apiClient = inject(ApiClientService);

  async getActiveFunds() {
    const response = await this.apiClient.fundos.get();
    return response?.items?.filter(f => f.status === 'Active') ?? [];
  }
}

// Component just uses the service
export class FundListComponent {
  private readonly fundService = inject(FundService);

  async ngOnInit() {
    const funds = await this.fundService.getActiveFunds();
  }
}
```

### 4. Handle Errors Gracefully

```typescript
async loadFunds() {
  try {
    this.loading.set(true);
    const response = await this.apiClient.fundos.get();
    this.funds.set(response?.items ?? []);
  } catch (error: any) {
    this.toastService.error(error.message || 'Failed to load funds');
    this.error.set(error.message);
  } finally {
    this.loading.set(false);
  }
}
```

### 5. Use Type Imports

```typescript
// ‚úÖ Good - Type-only import
import { type FundoCreateDto } from '@core-ledger/api-client';

// ‚ùå Avoid - Runtime import when only type is needed
import { FundoCreateDto } from '@core-ledger/api-client';
```

## API Client Files

Key files in the integration:

- `apps/core-ledger-ui/src/app/api/api-client.service.ts` - Angular service wrapper
- `apps/core-ledger-ui/src/app/api/angular-request-adapter.ts` - HttpClient bridge
- `libs/api-client/generated/` - Auto-generated Kiota code
- `libs/api-client/src/index.ts` - Public exports

## Regenerating the Client

When the API changes, regenerate the client:

```bash
# 1. Start API
npm run start:api

# 2. Export OpenAPI spec
npm run api:export-spec

# 3. Generate TypeScript client
npm run api:generate-client
```

## Summary

The Kiota-generated API client provides a type-safe, modern way to interact with the Core Ledger API:

- ‚úÖ Full TypeScript type safety
- ‚úÖ Seamless Angular integration
- ‚úÖ Works with mock API and interceptors
- ‚úÖ Modern async/await syntax
- ‚úÖ Auto-generated, always in sync

Happy coding! üöÄ
