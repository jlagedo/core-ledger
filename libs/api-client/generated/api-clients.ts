//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccount_TypesClient {
    /**
     * @return OK
     */
    getAllAccountTypes(): Observable<void>;
    /**
     * @return OK
     */
    createAccountType(body: CreateAccountTypeDto): Observable<void>;
    /**
     * @return OK
     */
    getAccountTypeById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateAccountType(id: number, body: UpdateAccountTypeDto): Observable<void>;
    /**
     * @return OK
     */
    deleteAccountType(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Account_TypesClient implements IAccount_TypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getAllAccountTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/accounttypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllAccountTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createAccountType(body: CreateAccountTypeDto): Observable<void> {
        let url_ = this.baseUrl + "/api/accounttypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateAccountType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAccountTypeById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/accounttypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAccountTypeById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateAccountType(id: number, body: UpdateAccountTypeDto): Observable<void> {
        let url_ = this.baseUrl + "/api/accounttypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAccountType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteAccountType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/accounttypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccountType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountsClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllAccounts(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    createAccount(body: CreateAccountDto): Observable<void>;
    /**
     * @return OK
     */
    getAccountsById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateAccount(id: number, body: UpdateAccountDto): Observable<void>;
    /**
     * @return OK
     */
    getAccountsByTypeReport(): Observable<void>;
    /**
     * @return OK
     */
    deactivateAccount(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountsClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllAccounts(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/accounts?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createAccount(body: CreateAccountDto): Observable<void> {
        let url_ = this.baseUrl + "/api/accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAccountsById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/accounts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAccountsById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateAccount(id: number, body: UpdateAccountDto): Observable<void> {
        let url_ = this.baseUrl + "/api/accounts/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAccountsByTypeReport(): Observable<void> {
        let url_ = this.baseUrl + "/api/accounts/reports/by-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsByTypeReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsByTypeReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAccountsByTypeReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deactivateAccount(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/accounts/{id}/deactivate";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeactivateAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IANBIMA_ClassificationsClient {
    /**
     * List ANBIMA classifications with optional filters.
     * @param classificacao_cvm (optional) 
     * @param nivel1 (optional) 
     * @param ativo (optional) 
     * @return OK
     */
    listarClassificacoesAnbima(classificacao_cvm?: string | undefined, nivel1?: string | undefined, ativo?: boolean | undefined): Observable<void>;
    /**
     * Get ANBIMA classification by codigo.
     * @return OK
     */
    obterClassificacaoAnbimaPorCodigo(codigo: string): Observable<void>;
    /**
     * Get hierarchical levels for ANBIMA classifications.
     * @param classificacao_cvm (optional) 
     * @return OK
     */
    listarNiveisAnbima(classificacao_cvm?: string | undefined): Observable<void>;
    /**
     * Verify compatibility between ANBIMA classification and CVM classification.
     * @return OK
     */
    verificarCompatibilidadeAnbima(codigo_anbima: string, classificacao_cvm: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ANBIMA_ClassificationsClient implements IANBIMA_ClassificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * List ANBIMA classifications with optional filters.
     * @param classificacao_cvm (optional) 
     * @param nivel1 (optional) 
     * @param ativo (optional) 
     * @return OK
     */
    listarClassificacoesAnbima(classificacao_cvm?: string | undefined, nivel1?: string | undefined, ativo?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/parametros/classificacoes-anbima?";
        if (classificacao_cvm === null)
            throw new globalThis.Error("The parameter 'classificacao_cvm' cannot be null.");
        else if (classificacao_cvm !== undefined)
            url_ += "classificacao_cvm=" + encodeURIComponent("" + classificacao_cvm) + "&";
        if (nivel1 === null)
            throw new globalThis.Error("The parameter 'nivel1' cannot be null.");
        else if (nivel1 !== undefined)
            url_ += "nivel1=" + encodeURIComponent("" + nivel1) + "&";
        if (ativo === null)
            throw new globalThis.Error("The parameter 'ativo' cannot be null.");
        else if (ativo !== undefined)
            url_ += "ativo=" + encodeURIComponent("" + ativo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarClassificacoesAnbima(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarClassificacoesAnbima(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processListarClassificacoesAnbima(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get ANBIMA classification by codigo.
     * @return OK
     */
    obterClassificacaoAnbimaPorCodigo(codigo: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/parametros/classificacoes-anbima/{codigo}";
        if (codigo === undefined || codigo === null)
            throw new globalThis.Error("The parameter 'codigo' must be defined.");
        url_ = url_.replace("{codigo}", encodeURIComponent("" + codigo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObterClassificacaoAnbimaPorCodigo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObterClassificacaoAnbimaPorCodigo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processObterClassificacaoAnbimaPorCodigo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get hierarchical levels for ANBIMA classifications.
     * @param classificacao_cvm (optional) 
     * @return OK
     */
    listarNiveisAnbima(classificacao_cvm?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/parametros/classificacoes-anbima/niveis?";
        if (classificacao_cvm === null)
            throw new globalThis.Error("The parameter 'classificacao_cvm' cannot be null.");
        else if (classificacao_cvm !== undefined)
            url_ += "classificacao_cvm=" + encodeURIComponent("" + classificacao_cvm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListarNiveisAnbima(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListarNiveisAnbima(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processListarNiveisAnbima(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Verify compatibility between ANBIMA classification and CVM classification.
     * @return OK
     */
    verificarCompatibilidadeAnbima(codigo_anbima: string, classificacao_cvm: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/parametros/classificacoes-anbima/verificar?";
        if (codigo_anbima === undefined || codigo_anbima === null)
            throw new globalThis.Error("The parameter 'codigo_anbima' must be defined and cannot be null.");
        else
            url_ += "codigo_anbima=" + encodeURIComponent("" + codigo_anbima) + "&";
        if (classificacao_cvm === undefined || classificacao_cvm === null)
            throw new globalThis.Error("The parameter 'classificacao_cvm' must be defined and cannot be null.");
        else
            url_ += "classificacao_cvm=" + encodeURIComponent("" + classificacao_cvm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificarCompatibilidadeAnbima(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificarCompatibilidadeAnbima(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerificarCompatibilidadeAnbima(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAudit_LogsClient {
    /**
     * @param sortBy (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllAuditLogs(limit: number, offset: number, sortDirection: string, sortBy?: string | undefined, filter?: string | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Audit_LogsClient implements IAudit_LogsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param sortBy (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllAuditLogs(limit: number, offset: number, sortDirection: string, sortBy?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auditlogs?";
        if (limit === undefined || limit === null)
            throw new globalThis.Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === undefined || offset === null)
            throw new globalThis.Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (sortDirection === undefined || sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' must be defined and cannot be null.");
        else
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllAuditLogs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICalendárioClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param search (optional) 
     * @param praca (optional) 
     * @param tipoDia (optional) 
     * @param diaUtil (optional) 
     * @param dataInicio (optional) 
     * @param dataFim (optional) 
     * @return OK
     */
    getAllCalendarios(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, search?: string | undefined, praca?: number | undefined, tipoDia?: number | undefined, diaUtil?: boolean | undefined, dataInicio?: string | undefined, dataFim?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    createCalendario(body: CreateCalendarioDto): Observable<void>;
    /**
     * @return OK
     */
    getCalendarioById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateCalendario(id: number, body: UpdateCalendarioDto): Observable<void>;
    /**
     * @return OK
     */
    deleteCalendario(id: number): Observable<void>;
    /**
     * @param praca (optional) 
     * @return OK
     */
    checkDiaUtil(data: string, praca?: Praca | undefined): Observable<void>;
    /**
     * @param praca (optional) 
     * @return OK
     */
    getProximoDiaUtil(data: string, praca?: Praca | undefined): Observable<void>;
    /**
     * @param praca (optional) 
     * @return OK
     */
    calcularDMais(data: string, dias: number, praca?: Praca | undefined): Observable<void>;
    /**
     * @param praca (optional) 
     * @return OK
     */
    importarCalendario(ano: number, praca?: Praca | undefined): Observable<void>;
    /**
     * @return OK
     */
    checkCalendarioHealth(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class CalendárioClient implements ICalendárioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param search (optional) 
     * @param praca (optional) 
     * @param tipoDia (optional) 
     * @param diaUtil (optional) 
     * @param dataInicio (optional) 
     * @param dataFim (optional) 
     * @return OK
     */
    getAllCalendarios(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, search?: string | undefined, praca?: number | undefined, tipoDia?: number | undefined, diaUtil?: boolean | undefined, dataInicio?: string | undefined, dataFim?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (praca === null)
            throw new globalThis.Error("The parameter 'praca' cannot be null.");
        else if (praca !== undefined)
            url_ += "Praca=" + encodeURIComponent("" + praca) + "&";
        if (tipoDia === null)
            throw new globalThis.Error("The parameter 'tipoDia' cannot be null.");
        else if (tipoDia !== undefined)
            url_ += "TipoDia=" + encodeURIComponent("" + tipoDia) + "&";
        if (diaUtil === null)
            throw new globalThis.Error("The parameter 'diaUtil' cannot be null.");
        else if (diaUtil !== undefined)
            url_ += "DiaUtil=" + encodeURIComponent("" + diaUtil) + "&";
        if (dataInicio === null)
            throw new globalThis.Error("The parameter 'dataInicio' cannot be null.");
        else if (dataInicio !== undefined)
            url_ += "DataInicio=" + encodeURIComponent("" + dataInicio) + "&";
        if (dataFim === null)
            throw new globalThis.Error("The parameter 'dataFim' cannot be null.");
        else if (dataFim !== undefined)
            url_ += "DataFim=" + encodeURIComponent("" + dataFim) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCalendarios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCalendarios(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllCalendarios(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createCalendario(body: CreateCalendarioDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCalendario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCalendario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCalendario(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCalendarioById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalendarioById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalendarioById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetCalendarioById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateCalendario(id: number, body: UpdateCalendarioDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCalendario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCalendario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCalendario(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteCalendario(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCalendario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCalendario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCalendario(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param praca (optional) 
     * @return OK
     */
    checkDiaUtil(data: string, praca?: Praca | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/dia-util/{data}?";
        if (data === undefined || data === null)
            throw new globalThis.Error("The parameter 'data' must be defined.");
        url_ = url_.replace("{data}", encodeURIComponent("" + data));
        if (praca === null)
            throw new globalThis.Error("The parameter 'praca' cannot be null.");
        else if (praca !== undefined)
            url_ += "praca=" + encodeURIComponent("" + praca) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDiaUtil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDiaUtil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckDiaUtil(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param praca (optional) 
     * @return OK
     */
    getProximoDiaUtil(data: string, praca?: Praca | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/proximo-dia-util/{data}?";
        if (data === undefined || data === null)
            throw new globalThis.Error("The parameter 'data' must be defined.");
        url_ = url_.replace("{data}", encodeURIComponent("" + data));
        if (praca === null)
            throw new globalThis.Error("The parameter 'praca' cannot be null.");
        else if (praca !== undefined)
            url_ += "praca=" + encodeURIComponent("" + praca) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProximoDiaUtil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProximoDiaUtil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetProximoDiaUtil(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param praca (optional) 
     * @return OK
     */
    calcularDMais(data: string, dias: number, praca?: Praca | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/calcular-d-mais/{data}/{dias}?";
        if (data === undefined || data === null)
            throw new globalThis.Error("The parameter 'data' must be defined.");
        url_ = url_.replace("{data}", encodeURIComponent("" + data));
        if (dias === undefined || dias === null)
            throw new globalThis.Error("The parameter 'dias' must be defined.");
        url_ = url_.replace("{dias}", encodeURIComponent("" + dias));
        if (praca === null)
            throw new globalThis.Error("The parameter 'praca' cannot be null.");
        else if (praca !== undefined)
            url_ += "praca=" + encodeURIComponent("" + praca) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcularDMais(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcularDMais(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCalcularDMais(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param praca (optional) 
     * @return OK
     */
    importarCalendario(ano: number, praca?: Praca | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/importar/{ano}?";
        if (ano === undefined || ano === null)
            throw new globalThis.Error("The parameter 'ano' must be defined.");
        url_ = url_.replace("{ano}", encodeURIComponent("" + ano));
        if (praca === null)
            throw new globalThis.Error("The parameter 'praca' cannot be null.");
        else if (praca !== undefined)
            url_ += "praca=" + encodeURIComponent("" + praca) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportarCalendario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportarCalendario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportarCalendario(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkCalendarioHealth(): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/calendario/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCalendarioHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCalendarioHealth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckCalendarioHealth(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClassesClient {
    /**
     * @return OK
     */
    getClassesByFundo(fundoId: string): Observable<void>;
    /**
     * @return OK
     */
    createClasse(fundoId: string, body: FundoClasseCreateDto): Observable<void>;
    /**
     * @return OK
     */
    getClasseById(id: string): Observable<void>;
    /**
     * @return OK
     */
    updateClasse(id: string, body: FundoClasseUpdateDto): Observable<void>;
    /**
     * @return OK
     */
    deleteClasse(id: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ClassesClient implements IClassesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getClassesByFundo(fundoId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/classes";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassesByFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassesByFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetClassesByFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createClasse(fundoId: string, body: FundoClasseCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/classes";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClasse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClasse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateClasse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getClasseById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/classes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClasseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClasseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetClasseById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateClasse(id: string, body: FundoClasseUpdateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/classes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClasse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClasse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateClasse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteClasse(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/classes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClasse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClasse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClasse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICore_JobsClient {
    /**
     * @param sortBy (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllCoreJobs(limit: number, offset: number, sortDirection: string, sortBy?: string | undefined, filter?: string | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Core_JobsClient implements ICore_JobsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param sortBy (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllCoreJobs(limit: number, offset: number, sortDirection: string, sortBy?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/corejobs?";
        if (limit === undefined || limit === null)
            throw new globalThis.Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === undefined || offset === null)
            throw new globalThis.Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (sortDirection === undefined || sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' must be defined and cannot be null.");
        else
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCoreJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCoreJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllCoreJobs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFundosClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllFundos(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    createFundo(body: FundoCreateDto): Observable<void>;
    /**
     * @return OK
     */
    getFundoById(id: string): Observable<void>;
    /**
     * @return OK
     */
    updateFundo(id: string, body: FundoUpdateDto): Observable<void>;
    /**
     * @return OK
     */
    deleteFundo(id: string): Observable<void>;
    /**
     * @return OK
     */
    getFundoByCnpj(cnpj: string): Observable<void>;
    /**
     * @return OK
     */
    searchFundos(termo: string, limit: number): Observable<void>;
    /**
     * Verifica se um CNPJ está disponível para cadastro de novo fundo.
     * @return OK
     */
    verificarCnpjDisponivel(cnpj: string): Observable<CnpjDisponibilidadeResponseDto>;
    /**
     * Cria um novo fundo via wizard com todas as entidades relacionadas.
     * @return Created
     */
    createFundoWizard(body: FundoWizardRequestDto): Observable<FundoWizardResponseDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FundosClient implements IFundosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllFundos(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFundos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFundos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllFundos(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createFundo(body: FundoCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getFundoById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFundoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFundoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetFundoById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateFundo(id: string, body: FundoUpdateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteFundo(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getFundoByCnpj(cnpj: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/cnpj/{cnpj}";
        if (cnpj === undefined || cnpj === null)
            throw new globalThis.Error("The parameter 'cnpj' must be defined.");
        url_ = url_.replace("{cnpj}", encodeURIComponent("" + cnpj));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFundoByCnpj(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFundoByCnpj(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetFundoByCnpj(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    searchFundos(termo: string, limit: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/busca?";
        if (termo === undefined || termo === null)
            throw new globalThis.Error("The parameter 'termo' must be defined and cannot be null.");
        else
            url_ += "termo=" + encodeURIComponent("" + termo) + "&";
        if (limit === undefined || limit === null)
            throw new globalThis.Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchFundos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFundos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSearchFundos(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Verifica se um CNPJ está disponível para cadastro de novo fundo.
     * @return OK
     */
    verificarCnpjDisponivel(cnpj: string): Observable<CnpjDisponibilidadeResponseDto> {
        let url_ = this.baseUrl + "/api/v1/fundos/verificar-cnpj/{cnpj}";
        if (cnpj === undefined || cnpj === null)
            throw new globalThis.Error("The parameter 'cnpj' must be defined.");
        url_ = url_.replace("{cnpj}", encodeURIComponent("" + cnpj));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerificarCnpjDisponivel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerificarCnpjDisponivel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CnpjDisponibilidadeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CnpjDisponibilidadeResponseDto>;
        }));
    }

    protected processVerificarCnpjDisponivel(response: HttpResponseBase): Observable<CnpjDisponibilidadeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CnpjDisponibilidadeResponseDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cria um novo fundo via wizard com todas as entidades relacionadas.
     * @return Created
     */
    createFundoWizard(body: FundoWizardRequestDto): Observable<FundoWizardResponseDto> {
        let url_ = this.baseUrl + "/api/v1/fundos/wizard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFundoWizard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFundoWizard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundoWizardResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundoWizardResponseDto>;
        }));
    }

    protected processCreateFundoWizard(response: HttpResponseBase): Observable<FundoWizardResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FundoWizardResponseDto;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Bad Request", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Conflict", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFundsClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllFunds(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    createFund(body: CreateFundDto): Observable<void>;
    /**
     * @return OK
     */
    getFundById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateFund(id: number, body: UpdateFundDto): Observable<void>;
    /**
     * @param q (optional) 
     * @return OK
     */
    autocompleteFunds(q?: string | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class FundsClient implements IFundsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllFunds(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/funds?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFunds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFunds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllFunds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createFund(body: CreateFundDto): Observable<void> {
        let url_ = this.baseUrl + "/api/funds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFund(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateFund(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getFundById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/funds/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFundById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFundById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetFundById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateFund(id: number, body: UpdateFundDto): Observable<void> {
        let url_ = this.baseUrl + "/api/funds/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFund(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateFund(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param q (optional) 
     * @return OK
     */
    autocompleteFunds(q?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/funds/autocomplete?";
        if (q === null)
            throw new globalThis.Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutocompleteFunds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutocompleteFunds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAutocompleteFunds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IHistoricosIndexadoresClient {
    /**
     * @return OK
     */
    createHistoricoIndexador(body: CreateHistoricoIndexadorDto): Observable<void>;
    /**
     * @return OK
     */
    deleteHistoricoIndexador(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class HistoricosIndexadoresClient implements IHistoricosIndexadoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    createHistoricoIndexador(body: CreateHistoricoIndexadorDto): Observable<void> {
        let url_ = this.baseUrl + "/api/historicos-indexadores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHistoricoIndexador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHistoricoIndexador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateHistoricoIndexador(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteHistoricoIndexador(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/historicos-indexadores/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHistoricoIndexador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHistoricoIndexador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteHistoricoIndexador(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIndexadoresClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param tipo (optional) 
     * @param periodicidade (optional) 
     * @param fonte (optional) 
     * @param ativo (optional) 
     * @param importacaoAutomatica (optional) 
     * @return OK
     */
    getAllIndexadores(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined, tipo?: number | undefined, periodicidade?: number | undefined, fonte?: string | undefined, ativo?: boolean | undefined, importacaoAutomatica?: boolean | undefined): Observable<void>;
    /**
     * @return OK
     */
    createIndexador(body: CreateIndexadorDto): Observable<void>;
    /**
     * @return OK
     */
    getIndexadorById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateIndexador(id: number, body: UpdateIndexadorDto): Observable<void>;
    /**
     * @return OK
     */
    deleteIndexador(id: number): Observable<void>;
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param dataInicio (optional) 
     * @param dataFim (optional) 
     * @return OK
     */
    getIndexadorHistorico(id: number, limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined, dataInicio?: Date | undefined, dataFim?: Date | undefined): Observable<void>;
    /**
     * @param dataInicio (optional) 
     * @param dataFim (optional) 
     * @return OK
     */
    exportIndexadorHistorico(id: number, dataInicio?: Date | undefined, dataFim?: Date | undefined): Observable<void>;
    /**
     * @param file (optional) 
     * @return OK
     */
    importIndexadorHistorico(id: number, sobrescrever: boolean, file?: FileParameter | undefined): Observable<void>;
    /**
     * @return OK
     */
    importarIndexador(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class IndexadoresClient implements IIndexadoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param tipo (optional) 
     * @param periodicidade (optional) 
     * @param fonte (optional) 
     * @param ativo (optional) 
     * @param importacaoAutomatica (optional) 
     * @return OK
     */
    getAllIndexadores(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined, tipo?: number | undefined, periodicidade?: number | undefined, fonte?: string | undefined, ativo?: boolean | undefined, importacaoAutomatica?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (tipo === null)
            throw new globalThis.Error("The parameter 'tipo' cannot be null.");
        else if (tipo !== undefined)
            url_ += "Tipo=" + encodeURIComponent("" + tipo) + "&";
        if (periodicidade === null)
            throw new globalThis.Error("The parameter 'periodicidade' cannot be null.");
        else if (periodicidade !== undefined)
            url_ += "Periodicidade=" + encodeURIComponent("" + periodicidade) + "&";
        if (fonte === null)
            throw new globalThis.Error("The parameter 'fonte' cannot be null.");
        else if (fonte !== undefined)
            url_ += "Fonte=" + encodeURIComponent("" + fonte) + "&";
        if (ativo === null)
            throw new globalThis.Error("The parameter 'ativo' cannot be null.");
        else if (ativo !== undefined)
            url_ += "Ativo=" + encodeURIComponent("" + ativo) + "&";
        if (importacaoAutomatica === null)
            throw new globalThis.Error("The parameter 'importacaoAutomatica' cannot be null.");
        else if (importacaoAutomatica !== undefined)
            url_ += "ImportacaoAutomatica=" + encodeURIComponent("" + importacaoAutomatica) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIndexadores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIndexadores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllIndexadores(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createIndexador(body: CreateIndexadorDto): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIndexador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIndexador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateIndexador(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getIndexadorById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndexadorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndexadorById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetIndexadorById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateIndexador(id: number, body: UpdateIndexadorDto): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIndexador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIndexador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateIndexador(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteIndexador(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIndexador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIndexador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteIndexador(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param dataInicio (optional) 
     * @param dataFim (optional) 
     * @return OK
     */
    getIndexadorHistorico(id: number, limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined, dataInicio?: Date | undefined, dataFim?: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}/historico?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dataInicio === null)
            throw new globalThis.Error("The parameter 'dataInicio' cannot be null.");
        else if (dataInicio !== undefined)
            url_ += "dataInicio=" + encodeURIComponent(dataInicio ? "" + dataInicio.toISOString() : "") + "&";
        if (dataFim === null)
            throw new globalThis.Error("The parameter 'dataFim' cannot be null.");
        else if (dataFim !== undefined)
            url_ += "dataFim=" + encodeURIComponent(dataFim ? "" + dataFim.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndexadorHistorico(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndexadorHistorico(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetIndexadorHistorico(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dataInicio (optional) 
     * @param dataFim (optional) 
     * @return OK
     */
    exportIndexadorHistorico(id: number, dataInicio?: Date | undefined, dataFim?: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}/historico/exportar?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (dataInicio === null)
            throw new globalThis.Error("The parameter 'dataInicio' cannot be null.");
        else if (dataInicio !== undefined)
            url_ += "dataInicio=" + encodeURIComponent(dataInicio ? "" + dataInicio.toISOString() : "") + "&";
        if (dataFim === null)
            throw new globalThis.Error("The parameter 'dataFim' cannot be null.");
        else if (dataFim !== undefined)
            url_ += "dataFim=" + encodeURIComponent(dataFim ? "" + dataFim.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportIndexadorHistorico(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportIndexadorHistorico(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExportIndexadorHistorico(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    importIndexadorHistorico(id: number, sobrescrever: boolean, file?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}/historico/importar?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sobrescrever === undefined || sobrescrever === null)
            throw new globalThis.Error("The parameter 'sobrescrever' must be defined and cannot be null.");
        else
            url_ += "sobrescrever=" + encodeURIComponent("" + sobrescrever) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportIndexadorHistorico(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportIndexadorHistorico(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportIndexadorHistorico(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    importarIndexador(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/indexadores/{id}/importar";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportarIndexador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportarIndexador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportarIndexador(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IInstituicoesClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param search (optional) 
     * @param ativo (optional) 
     * @return OK
     */
    getAllInstituicoes(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined, search?: string | undefined, ativo?: boolean | undefined): Observable<void>;
    /**
     * @return OK
     */
    createInstituicao(body: CreateInstituicaoDto): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class InstituicoesClient implements IInstituicoesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @param search (optional) 
     * @param ativo (optional) 
     * @return OK
     */
    getAllInstituicoes(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined, search?: string | undefined, ativo?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/instituicoes?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (ativo === null)
            throw new globalThis.Error("The parameter 'ativo' cannot be null.");
        else if (ativo !== undefined)
            url_ += "ativo=" + encodeURIComponent("" + ativo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInstituicoes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInstituicoes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllInstituicoes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createInstituicao(body: CreateInstituicaoDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/instituicoes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInstituicao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInstituicao(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateInstituicao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IJobs_IngestionClient {
    /**
     * @return OK
     */
    importB3InstructionFile(): Observable<void>;
    /**
     * @return OK
     */
    testConnection(body: TestConnectionRequest): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Jobs_IngestionClient implements IJobs_IngestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    importB3InstructionFile(): Observable<void> {
        let url_ = this.baseUrl + "/api/jobs-ingestion/import-b3-instruction-file";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportB3InstructionFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportB3InstructionFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportB3InstructionFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testConnection(body: TestConnectionRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/jobs-ingestion/test-connection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestConnection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestConnection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPrazosClient {
    /**
     * @return OK
     */
    getPrazosByFundo(fundoId: string, incluirInativos: boolean): Observable<void>;
    /**
     * @return OK
     */
    createPrazo(fundoId: string, body: FundoPrazoCreateDto): Observable<void>;
    /**
     * @return OK
     */
    updatePrazo(id: number, body: FundoPrazoUpdateDto): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class PrazosClient implements IPrazosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getPrazosByFundo(fundoId: string, incluirInativos: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/prazos?";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        if (incluirInativos === undefined || incluirInativos === null)
            throw new globalThis.Error("The parameter 'incluirInativos' must be defined and cannot be null.");
        else
            url_ += "incluirInativos=" + encodeURIComponent("" + incluirInativos) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrazosByFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrazosByFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetPrazosByFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createPrazo(fundoId: string, body: FundoPrazoCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/prazos";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePrazo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePrazo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePrazo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updatePrazo(id: number, body: FundoPrazoUpdateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/prazos/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePrazo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePrazo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePrazo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecuritiesClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllSecurities(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    createSecurity(body: CreateSecurityDto): Observable<void>;
    /**
     * @return OK
     */
    getSecuritiesById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateSecurity(id: number, body: UpdateSecurityDto): Observable<void>;
    /**
     * @param q (optional) 
     * @return OK
     */
    autocompleteSecurities(q?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    deactivateSecurity(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class SecuritiesClient implements ISecuritiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllSecurities(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/securities?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSecurities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSecurities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllSecurities(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createSecurity(body: CreateSecurityDto): Observable<void> {
        let url_ = this.baseUrl + "/api/securities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSecurity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSecurity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateSecurity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSecuritiesById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSecuritiesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSecuritiesById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetSecuritiesById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateSecurity(id: number, body: UpdateSecurityDto): Observable<void> {
        let url_ = this.baseUrl + "/api/securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSecurity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSecurity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSecurity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param q (optional) 
     * @return OK
     */
    autocompleteSecurities(q?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/securities/autocomplete?";
        if (q === null)
            throw new globalThis.Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutocompleteSecurities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutocompleteSecurities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAutocompleteSecurities(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deactivateSecurity(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/securities/{id}/deactivate";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateSecurity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateSecurity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeactivateSecurity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurity_TypesClient {
    /**
     * @return OK
     */
    getAllSecurityTypes(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Security_TypesClient implements ISecurity_TypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getAllSecurityTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/securitytypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSecurityTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSecurityTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllSecurityTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITaxasClient {
    /**
     * @return OK
     */
    getTaxasByFundo(fundoId: string, incluirInativas: boolean): Observable<void>;
    /**
     * @return OK
     */
    createTaxa(fundoId: string, body: FundoTaxaCreateDto): Observable<void>;
    /**
     * @return OK
     */
    updateTaxa(id: number, body: FundoTaxaUpdateDto): Observable<void>;
    /**
     * @return OK
     */
    deleteTaxa(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class TaxasClient implements ITaxasClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getTaxasByFundo(fundoId: string, incluirInativas: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/taxas?";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        if (incluirInativas === undefined || incluirInativas === null)
            throw new globalThis.Error("The parameter 'incluirInativas' must be defined and cannot be null.");
        else
            url_ += "incluirInativas=" + encodeURIComponent("" + incluirInativas) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxasByFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxasByFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTaxasByFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createTaxa(fundoId: string, body: FundoTaxaCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/taxas";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaxa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaxa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTaxa(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateTaxa(id: number, body: FundoTaxaUpdateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/taxas/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTaxa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaxa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTaxa(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteTaxa(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/taxas/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaxa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaxa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTaxa(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITransaction_StatusesClient {
    /**
     * @return OK
     */
    getAllTransactionStatuses(): Observable<void>;
    /**
     * @return OK
     */
    getTransactionStatusById(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Transaction_StatusesClient implements ITransaction_StatusesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getAllTransactionStatuses(): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransactionStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactionStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllTransactionStatuses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTransactionStatusById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/status/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionStatusById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionStatusById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTransactionStatusById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITransaction_SubTypesClient {
    /**
     * @param typeId (optional) 
     * @return OK
     */
    getAllTransactionSubTypes(typeId?: number | undefined): Observable<void>;
    /**
     * @return OK
     */
    getTransactionSubTypeById(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Transaction_SubTypesClient implements ITransaction_SubTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param typeId (optional) 
     * @return OK
     */
    getAllTransactionSubTypes(typeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/subtypes?";
        if (typeId === null)
            throw new globalThis.Error("The parameter 'typeId' cannot be null.");
        else if (typeId !== undefined)
            url_ += "typeId=" + encodeURIComponent("" + typeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransactionSubTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactionSubTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllTransactionSubTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTransactionSubTypeById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/subtypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionSubTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionSubTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTransactionSubTypeById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITransaction_TypesClient {
    /**
     * @return OK
     */
    getAllTransactionTypes(): Observable<void>;
    /**
     * @return OK
     */
    getTransactionTypeById(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Transaction_TypesClient implements ITransaction_TypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getAllTransactionTypes(): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransactionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactionTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllTransactionTypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTransactionTypeById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/types/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTransactionTypeById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITransactionsClient {
    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllTransactions(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void>;
    /**
     * @return OK
     */
    createTransaction(body: CreateTransactionDto): Observable<void>;
    /**
     * @return OK
     */
    getTransactionById(id: number): Observable<void>;
    /**
     * @return OK
     */
    updateTransaction(id: number, body: UpdateTransactionDto): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class TransactionsClient implements ITransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     * @param filter (optional) 
     * @return OK
     */
    getAllTransactions(limit?: number | undefined, offset?: number | undefined, sortBy?: string | undefined, sortDirection?: string | undefined, filter?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (sortBy === null)
            throw new globalThis.Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filter === null)
            throw new globalThis.Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAllTransactions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createTransaction(body: CreateTransactionDto): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTransactionById(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTransactionById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateTransaction(id: number, body: UpdateTransactionDto): Observable<void> {
        let url_ = this.baseUrl + "/api/transactions/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUsersClient {
    /**
     * @return OK
     */
    getCurrentUser(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getCurrentUser(): Observable<void> {
        let url_ = this.baseUrl + "/api/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVinculosClient {
    /**
     * @return OK
     */
    getVinculosByFundo(fundoId: string, incluirEncerrados: boolean): Observable<void>;
    /**
     * @return OK
     */
    createVinculo(fundoId: string, body: CreateFundoVinculoDto): Observable<void>;
    /**
     * @return OK
     */
    encerrarVinculo(id: number, body: EncerrarVinculoDto): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class VinculosClient implements IVinculosClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * @return OK
     */
    getVinculosByFundo(fundoId: string, incluirEncerrados: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/vinculos?";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        if (incluirEncerrados === undefined || incluirEncerrados === null)
            throw new globalThis.Error("The parameter 'incluirEncerrados' must be defined and cannot be null.");
        else
            url_ += "incluirEncerrados=" + encodeURIComponent("" + incluirEncerrados) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVinculosByFundo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVinculosByFundo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetVinculosByFundo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createVinculo(fundoId: string, body: CreateFundoVinculoDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/fundos/{fundoId}/vinculos";
        if (fundoId === undefined || fundoId === null)
            throw new globalThis.Error("The parameter 'fundoId' must be defined.");
        url_ = url_.replace("{fundoId}", encodeURIComponent("" + fundoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVinculo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVinculo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateVinculo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    encerrarVinculo(id: number, body: EncerrarVinculoDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/vinculos/{id}/encerrar";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEncerrarVinculo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEncerrarVinculo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEncerrarVinculo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWorker_NotificationsClient {
    /**
     * Receives notification from Worker that a transaction has been processed.
    Broadcasts to the user who created the transaction via SignalR.
     * @return OK
     */
    transactionProcessed(body: TransactionProcessedNotification): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Worker_NotificationsClient implements IWorker_NotificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7109";
    }

    /**
     * Receives notification from Worker that a transaction has been processed.
    Broadcasts to the user who created the transaction via SignalR.
     * @return OK
     */
    transactionProcessed(body: TransactionProcessedNotification): Observable<void> {
        let url_ = this.baseUrl + "/api/worker-notifications/transaction-processed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionProcessed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionProcessed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransactionProcessed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Notification payload sent by Worker after processing a transaction. */
export interface TransactionProcessedNotification {
    /** The ID of the processed transaction. */
    transactionId?: number;
    /** Whether the processing succeeded. */
    success?: boolean;
    /** The final status ID (2=Executed, 8=Failed). */
    finalStatusId?: number;
    /** Error message if processing failed. */
    errorMessage?: string | undefined;
    /** UTC timestamp when processing completed. */
    processedAt?: Date;
    /** Correlation ID for distributed tracing. */
    correlationId?: string | undefined;
    /** User ID of the person who created the transaction (may be null for batch operations). */
    createdByUserId?: string | undefined;
}

export interface CreateAccountDto {
    code?: number;
    name?: string | undefined;
    typeId?: number;
    status?: AccountStatus;
    normalBalance?: NormalBalance;
}

export interface CreateAccountTypeDto {
    description?: string | undefined;
}

export interface CreateCalendarioDto {
    data?: Date;
    tipoDia?: TipoDia;
    praca?: Praca;
    descricao?: string | undefined;
}

export interface CreateFundDto {
    code: string;
    name: string;
    baseCurrency: string;
    inceptionDate: Date;
    valuationFrequency: ValuationFrequency;
}

export interface CreateFundoVinculoDto {
    fundoId: string;
    instituicaoId: number;
    tipoVinculo: TipoVinculoInstitucional;
    dataInicio: Date;
    contratoNumero?: string | undefined;
    observacao?: string | undefined;
    principal?: boolean;
}

export interface CreateHistoricoIndexadorDto {
    indexadorId: number;
    dataReferencia: Date;
    valor: number;
    fatorDiario?: number | undefined;
    variacaoPercentual?: number | undefined;
    fonte?: string | undefined;
    importacaoId?: string | undefined;
}

export interface CreateIndexadorDto {
    codigo: string;
    nome: string;
    tipo: IndexadorTipo;
    fonte?: string | undefined;
    periodicidade: Periodicidade;
    fatorAcumulado?: number | undefined;
    dataBase?: Date | undefined;
    urlFonte?: string | undefined;
    importacaoAutomatica?: boolean;
    ativo?: boolean;
}

export interface CreateInstituicaoDto {
    cnpj: string;
    razaoSocial: string;
    nomeFantasia?: string | undefined;
    ativo?: boolean;
}

export interface CreateSecurityDto {
    name: string;
    ticker: string;
    isin?: string | undefined;
    type: SecurityType;
    currency: string;
}

export interface CreateTransactionDto {
    fundId?: number;
    securityId?: number | undefined;
    transactionSubTypeId?: number;
    tradeDate?: Date;
    settleDate?: Date;
    quantity?: number;
    price?: number;
    amount?: number;
    currency?: string | undefined;
    idempotencyKey?: string | undefined;
}

export interface EncerrarVinculoDto {
    dataFim: Date;
}

export interface CnpjDisponibilidadeResponseDto {
    cnpj?: string | undefined;
    disponivel?: boolean;
    cnpjValido?: boolean;
    mensagem?: string | undefined;
}

export interface FundoCreateDto {
    cnpj?: string | undefined;
    razaoSocial?: string | undefined;
    tipoFundo?: TipoFundo;
    classificacaoCVM?: ClassificacaoCVM;
    prazo?: PrazoFundo;
    publicoAlvo?: PublicoAlvo;
    tributacao?: TributacaoFundo;
    condominio?: TipoCondominio;
    nomeFantasia?: string | undefined;
    nomeCurto?: string | undefined;
    dataConstituicao?: Date | undefined;
    dataInicioAtividade?: Date | undefined;
    classificacaoAnbima?: string | undefined;
    codigoAnbima?: string | undefined;
    exclusivo?: boolean;
    reservado?: boolean;
    permiteAlavancagem?: boolean;
    aceitaCripto?: boolean;
    percentualExterior?: number;
}

export interface FundoUpdateDto {
    razaoSocial?: string | undefined;
    nomeFantasia?: string | undefined;
    nomeCurto?: string | undefined;
    dataConstituicao?: Date | undefined;
    dataInicioAtividade?: Date | undefined;
    classificacaoCVM?: ClassificacaoCVM;
    classificacaoAnbima?: string | undefined;
    codigoAnbima?: string | undefined;
    prazo?: PrazoFundo;
    publicoAlvo?: PublicoAlvo;
    tributacao?: TributacaoFundo;
    condominio?: TipoCondominio;
    exclusivo?: boolean | undefined;
    reservado?: boolean | undefined;
    permiteAlavancagem?: boolean | undefined;
    aceitaCripto?: boolean | undefined;
    percentualExterior?: number | undefined;
}

export interface FundoClasseCreateDto {
    codigoClasse?: string | undefined;
    nomeClasse?: string | undefined;
    cnpjClasse?: string | undefined;
    tipoClasseFidc?: TipoClasseFIDC;
    ordemSubordinacao?: number | undefined;
    rentabilidadeAlvo?: number | undefined;
    responsabilidadeLimitada?: boolean;
    segregacaoPatrimonial?: boolean;
    valorMinimoAplicacao?: number | undefined;
}

export interface FundoClasseUpdateDto {
    nomeClasse?: string | undefined;
    cnpjClasse?: string | undefined;
    tipoClasseFidc?: TipoClasseFIDC;
    ordemSubordinacao?: number | undefined;
    rentabilidadeAlvo?: number | undefined;
    responsabilidadeLimitada?: boolean;
    segregacaoPatrimonial?: boolean;
    valorMinimoAplicacao?: number | undefined;
}

export interface FundoPrazoCreateDto {
    tipoPrazo?: TipoPrazoOperacional;
    diasCotizacao?: number;
    diasLiquidacao?: number;
    horarioLimite?: string;
    diasUteis?: boolean;
    classeId?: string | undefined;
    diasCarencia?: number | undefined;
    calendarioId?: number | undefined;
    permiteParcial?: boolean;
    percentualMinimo?: number | undefined;
    valorMinimo?: number | undefined;
}

export interface FundoPrazoUpdateDto {
    diasCotizacao?: number;
    diasLiquidacao?: number;
    horarioLimite?: string;
    diasUteis?: boolean;
    diasCarencia?: number | undefined;
    calendarioId?: number | undefined;
    permiteParcial?: boolean;
    percentualMinimo?: number | undefined;
    valorMinimo?: number | undefined;
}

export interface FundoTaxaCreateDto {
    tipoTaxa?: TipoTaxa;
    percentual?: number;
    baseCalculo?: BaseCalculoTaxa;
    periodicidadeProvisao?: PeriodicidadeProvisao;
    periodicidadePagamento?: PeriodicidadePagamento;
    dataInicioVigencia?: Date;
    classeId?: string | undefined;
    diaPagamento?: number | undefined;
    valorMinimo?: number | undefined;
    valorMaximo?: number | undefined;
    parametrosPerformance?: FundoTaxaPerformanceCreateDto;
}

export interface FundoTaxaPerformanceCreateDto {
    indexadorId?: number;
    percentualBenchmark?: number;
    metodoCalculo?: MetodoCalculoPerformance;
    linhaDagua?: boolean;
    periodicidadeCristalizacao?: PeriodicidadeCristalizacao;
    mesCristalizacao?: number | undefined;
}

export interface FundoTaxaUpdateDto {
    percentual?: number;
    baseCalculo?: BaseCalculoTaxa;
    periodicidadeProvisao?: PeriodicidadeProvisao;
    periodicidadePagamento?: PeriodicidadePagamento;
    diaPagamento?: number | undefined;
    valorMinimo?: number | undefined;
    valorMaximo?: number | undefined;
}

export interface TestConnectionRequest {
    referenceId?: string | undefined;
    jobDescription?: string | undefined;
}

export interface UpdateAccountDto {
    code?: number;
    name?: string | undefined;
    typeId?: number;
    status?: AccountStatus;
    normalBalance?: NormalBalance;
}

export interface UpdateAccountTypeDto {
    description?: string | undefined;
}

export interface UpdateCalendarioDto {
    tipoDia?: TipoDia;
    descricao?: string | undefined;
}

export interface UpdateFundDto {
    code: string;
    name: string;
    baseCurrency: string;
    inceptionDate: Date;
    valuationFrequency: ValuationFrequency;
}

export interface UpdateIndexadorDto {
    nome: string;
    fonte?: string | undefined;
    fatorAcumulado?: number | undefined;
    dataBase?: Date | undefined;
    urlFonte?: string | undefined;
    importacaoAutomatica?: boolean;
    ativo?: boolean;
}

export interface UpdateSecurityDto {
    name: string;
    ticker: string;
    isin?: string | undefined;
    type: SecurityType;
    currency: string;
}

export interface UpdateTransactionDto {
    fundId?: number;
    securityId?: number | undefined;
    transactionSubTypeId?: number;
    tradeDate?: Date;
    settleDate?: Date;
    quantity?: number;
    price?: number;
    amount?: number;
    currency?: string | undefined;
    statusId?: number;
}

export interface FundoWizardRequestDto {
    identificacao?: WizardIdentificacaoDto;
    classificacao?: WizardClassificacaoDto;
    caracteristicas?: WizardCaracteristicasDto;
    parametrosCota?: WizardParametrosCotaDto;
    taxas?: WizardTaxaDto[] | undefined;
    prazos?: WizardPrazoDto[] | undefined;
    vinculos?: WizardVinculoDto[] | undefined;
    classes?: WizardClasseDto[] | undefined;
    parametrosFidc?: WizardParametrosFidcDto;
    rascunhoId?: string | undefined;
    documentosTempIds?: string[] | undefined;
}

export interface FundoWizardResponseDto {
    id?: string;
    cnpj?: string | undefined;
    razaoSocial?: string | undefined;
    nomeFantasia?: string | undefined;
    tipoFundo?: TipoFundo;
    situacao?: SituacaoFundo;
    createdAt?: Date;
}

export interface WizardCaracteristicasDto {
    condominio?: TipoCondominio;
    prazo?: PrazoFundo;
    dataEncerramento?: Date | undefined;
    exclusivo?: boolean;
    reservado?: boolean;
    permiteAlavancagem?: boolean;
    limiteAlavancagem?: number | undefined;
    aceitaCripto?: boolean;
    percentualExterior?: number;
}

export interface WizardClasseDto {
    codigoClasse?: string | undefined;
    nomeClasse?: string | undefined;
    publicoAlvo?: PublicoAlvo;
    dataInicio?: Date;
    cnpjClasse?: string | undefined;
    classePaiId?: string | undefined;
    nivel?: number;
    tipoClasseFidc?: TipoClasseFIDC;
    ordemSubordinacao?: number | undefined;
    rentabilidadeAlvo?: number | undefined;
    indiceSubordinacaoMinimo?: number | undefined;
    valorMinimoAplicacao?: number | undefined;
    valorMinimoPermanencia?: number | undefined;
    responsabilidadeLimitada?: boolean;
    segregacaoPatrimonial?: boolean;
    taxaAdministracao?: number | undefined;
    taxaGestao?: number | undefined;
    taxaPerformance?: number | undefined;
    benchmarkId?: number | undefined;
    permiteResgateAntecipado?: boolean;
    dataEncerramento?: Date | undefined;
}

export interface WizardClassificacaoDto {
    classificacaoCvm?: ClassificacaoCVM;
    publicoAlvo?: PublicoAlvo;
    tributacao?: TributacaoFundo;
    classificacaoAnbima?: string | undefined;
    codigoAnbima?: string | undefined;
}

export interface WizardIdentificacaoDto {
    cnpj?: string | undefined;
    razaoSocial?: string | undefined;
    tipoFundo?: TipoFundo;
    dataConstituicao?: Date;
    dataInicioAtividade?: Date;
    nomeFantasia?: string | undefined;
    nomeCurto?: string | undefined;
}

export interface WizardParametrosCotaDto {
    tipoCota?: TipoCota;
    horarioCorte?: string;
    cotaInicial?: number;
    dataCotaInicial?: Date;
    casasDecimaisCota?: number;
    casasDecimaisQuantidade?: number;
    casasDecimaisPl?: number;
    fusoHorario?: string | undefined;
    permiteCotaEstimada?: boolean;
}

export interface WizardParametrosFidcDto {
    tipoFidc?: TipoFIDC;
    tiposRecebiveis?: TipoRecebiveis[] | undefined;
    prazoMedioCarteira?: number | undefined;
    indiceSubordinacaoAlvo?: number | undefined;
    provisaoDevedoresDuvidosos?: number | undefined;
    limiteConcentracaoCedente?: number | undefined;
    limiteConcentracaoSacado?: number | undefined;
    possuiCoobrigacao?: boolean;
    percentualCoobrigacao?: number | undefined;
    permiteCessaoParcial?: boolean;
    ratingMinimo?: string | undefined;
    agenciaRating?: string | undefined;
    registradoraRecebiveis?: Registradora;
    contaRegistradora?: string | undefined;
    integracaoRegistradora?: boolean;
}

export interface WizardPrazoDto {
    tipoOperacao?: TipoPrazoOperacional;
    prazoCotizacao?: number;
    prazoLiquidacao?: number;
    tipoCalendario?: string | undefined;
    valorMinimoInicial?: number | undefined;
    valorMinimoAdicional?: number | undefined;
    valorMinimoResgate?: number | undefined;
    valorMinimoPermanencia?: number | undefined;
    prazoCarenciaDias?: number | undefined;
    permiteResgateTotal?: boolean;
    permiteResgateProgramado?: boolean;
    prazoMaximoProgramacao?: number | undefined;
    classeId?: string | undefined;
}

export interface WizardTaxaDto {
    tipoTaxa?: TipoTaxa;
    percentual?: number;
    baseCalculo?: BaseCalculoTaxa;
    formaCobranca?: PeriodicidadePagamento;
    dataInicioVigencia?: Date;
    percentualMinimo?: number | undefined;
    percentualMaximo?: number | undefined;
    dataFimVigencia?: Date | undefined;
    benchmarkId?: number | undefined;
    percentualBenchmark?: number | undefined;
    possuiHurdle?: boolean;
    possuiHighWaterMark?: boolean;
    linhaDaguaGlobal?: boolean | undefined;
    classeId?: string | undefined;
}

export interface WizardVinculoDto {
    tipoVinculo?: TipoVinculoInstitucional;
    cnpjInstituicao?: string | undefined;
    nomeInstituicao?: string | undefined;
    dataInicio?: Date;
    codigoCvm?: string | undefined;
    dataFim?: Date | undefined;
    motivoFim?: string | undefined;
    responsavelNome?: string | undefined;
    responsavelEmail?: string | undefined;
    responsavelTelefone?: string | undefined;
}

export enum BaseCalculoTaxa {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ClassificacaoCVM {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export enum MetodoCalculoPerformance {
    _1 = 1,
    _2 = 2,
}

export enum PeriodicidadeCristalizacao {
    _1 = 1,
    _2 = 2,
}

export enum PeriodicidadePagamento {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum PeriodicidadeProvisao {
    _1 = 1,
    _2 = 2,
}

export enum PrazoFundo {
    _1 = 1,
    _2 = 2,
}

export enum PublicoAlvo {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum Registradora {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum SituacaoFundo {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum TipoClasseFIDC {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TipoCondominio {
    _1 = 1,
    _2 = 2,
}

export enum TipoCota {
    _1 = 1,
    _2 = 2,
}

export enum TipoFIDC {
    _1 = 1,
    _2 = 2,
}

export enum TipoFundo {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum TipoPrazoOperacional {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TipoRecebiveis {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _99 = 99,
}

export enum TipoTaxa {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export enum TipoVinculoInstitucional {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
}

export enum TributacaoFundo {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum AccountStatus {
    _1 = 1,
    _2 = 2,
}

export enum IndexadorTipo {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum NormalBalance {
    _1 = 1,
    _2 = 2,
}

export enum Periodicidade {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum Praca {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum SecurityType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
}

export enum TipoDia {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum ValuationFrequency {
    _1 = 1,
    _2 = 2,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}